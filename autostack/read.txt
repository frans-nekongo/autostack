Chat.Models

export interface IConversationMessage {
  role: string
  content: string
  timestamp: string
}

export interface IConversationSession {
  id: string
  messages: IConversationMessage[]
  lastGeneratedConfig: any 
}

export interface IChatState {
  currentSessionId: string | null;
  conversation: IConversationSession | null;
  sessions: IConversationSession[];
  loading: boolean;
  error: string | null;
  isCreatingNewSession: boolean;
}

export const initialChatState: IChatState = {
  currentSessionId: null,
  conversation: null,
  sessions: [],
  loading: false,
  error: null,
  isCreatingNewSession: false,
};


Chat.Effects

import { Injectable, inject } from '@angular/core';
import { createEffect, Actions, ofType } from '@ngrx/effects';
import { Router } from '@angular/router';
import { switchMap, map, catchError, tap } from 'rxjs/operators';
import { of } from 'rxjs';

import { ChatActions } from './chat.actions';
import { ChatService } from '../../services/chat/chat-service';

@Injectable()
export class ChatEffects {
  private actions$ = inject(Actions);
  private chatService = inject(ChatService);
  private router = inject(Router);

  // Load existing conversation
  setConversation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.setConversation),
      switchMap(({ id }) =>
        this.chatService.getConversation(id).pipe(
          map((conversation) =>
            ChatActions.setConversationSuccess({ conversation })
          ),
          catchError((error) =>
            of(ChatActions.setConversationFailure({ error: error.message }))
          )
        )
      )
    )
  );

  // Create new conversation with initial message
  setNewConversation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.setNewConversation),
      switchMap(({ content }) =>
        this.chatService.createNewConversation(content).pipe(
          map(({ conversation, architectureResult }) =>
            ChatActions.setNewConversationSuccess({ conversation, architectureResult })
          ),
          catchError((error) =>
            of(ChatActions.setNewConversationFailure({ error: error.message }))
          )
        )
      )
    )
  );

  // Navigate to chat page after successful conversation creation
  navigateToChat$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(ChatActions.setNewConversationSuccess),
        tap(({ conversation }) => {
          this.router.navigate(['/chat', conversation.id]);
        })
      ),
    { dispatch: false }
  );

  // Send message in existing conversation
  sendMessage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.sendMessage),
      switchMap(({ content }) =>
        this.chatService.sendMessage(content).pipe(
          map(({ message, architectureResult }) =>
            ChatActions.sendMessageSuccess({ message, architectureResult })
          ),
          catchError((error) =>
            of(ChatActions.sendMessageFailure({ error: error.message }))
          )
        )
      )
    )
  );

  // Load user sessions
  loadSessions$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.loadSessions),
      switchMap(({ userId }) =>
        this.chatService.loadUserSessions(userId).pipe(
          map((sessions) =>
            ChatActions.loadSessionsSuccess({ sessions })
          ),
          catchError((error) =>
            of(ChatActions.loadSessionsFailure({ error: error.message }))
          )
        )
      )
    )
  );

  // Clear conversation
  clearConversation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.clearConversation),
      switchMap(({ sessionId }) =>
        this.chatService.clearConversation(sessionId).pipe(
          map(() =>
            ChatActions.clearConversationSuccess({ sessionId })
          ),
          catchError((error) =>
            of(ChatActions.clearConversationFailure({ error: error.message }))
          )
        )
      )
    )
  );

  // Delete session
  deleteSession$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.deleteSession),
      switchMap(({ sessionId }) =>
        this.chatService.deleteSession(sessionId).pipe(
          map(() =>
            ChatActions.deleteSessionSuccess({ sessionId })
          ),
          catchError((error) =>
            of(ChatActions.deleteSessionFailure({ error: error.message }))
          )
        )
      )
    )
  );
}

Chat.Facade

import { Injectable, inject } from '@angular/core';
import { Store } from '@ngrx/store';
import { Observable } from 'rxjs';

import { ChatActions } from './chat.actions';
import * as ChatSelectors from './chat.selectors';
import { IConversationSession, IConversationMessage } from './chat.models';

@Injectable({
  providedIn: 'root',
})
export class ChatFacade {
  private readonly store = inject(Store);

  // Selectors
  conversation$ = this.store.select(ChatSelectors.selectConversation);
  currentSessionId$ = this.store.select(ChatSelectors.selectCurrentSessionId);
  messages$ = this.store.select(ChatSelectors.selectConversationMessages);
  lastConfig$ = this.store.select(ChatSelectors.selectLastGeneratedConfig);
  sessions$ = this.store.select(ChatSelectors.selectSessions);
  sessionsCount$ = this.store.select(ChatSelectors.selectSessionsCount);
  loading$ = this.store.select(ChatSelectors.selectConversationLoading);
  error$ = this.store.select(ChatSelectors.selectConversationError);
  hasError$ = this.store.select(ChatSelectors.selectHasError);
  hasConversation$ = this.store.select(ChatSelectors.selectHasConversation);
  isCreatingNewSession$ = this.store.select(ChatSelectors.selectIsCreatingNewSession);

  // Actions
  setConversation(id: string): void {
    this.store.dispatch(ChatActions.setConversation({ id }));
  }

  setNewConversation(content: string, userId?: string): void {
    this.store.dispatch(ChatActions.setNewConversation({ content, userId }));
  }

  sendMessage(content: string): void {
    this.store.dispatch(ChatActions.sendMessage({ content }));
  }

  loadSessions(userId: string): void {
    this.store.dispatch(ChatActions.loadSessions({ userId }));
  }

  clearConversation(sessionId: string): void {
    this.store.dispatch(ChatActions.clearConversation({ sessionId }));
  }

  deleteSession(sessionId: string): void {
    this.store.dispatch(ChatActions.deleteSession({ sessionId }));
  }

  resetChatState(): void {
    this.store.dispatch(ChatActions.resetChatState());
  }
}

Chat.Reducer

import { createReducer, on, Action } from '@ngrx/store';
import { ChatActions } from './chat.actions';
import { IChatState, initialChatState } from './chat.models';

export const CHAT_FEATURE_KEY = 'chat';

export interface ChatState {
  readonly [CHAT_FEATURE_KEY]: IChatState;
}

export interface ChatPartialState {
  readonly [CHAT_FEATURE_KEY]: IChatState;
}

const reducer = createReducer(
  initialChatState,

  // Set Conversation
  on(ChatActions.setConversation, (state, { id }) => ({
    ...state,
    currentSessionId: id,
    loading: true,
    error: null,
  })),
  on(ChatActions.setConversationSuccess, (state, { conversation }) => ({
    ...state,
    conversation,
    currentSessionId: conversation.id,
    loading: false,
    error: null,
  })),
  on(ChatActions.setConversationFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
  })),

  // Set New Conversation
  on(ChatActions.setNewConversation, (state) => ({
    ...state,
    isCreatingNewSession: true,
    loading: true,
    error: null,
  })),
  on(
    ChatActions.setNewConversationSuccess,
    (state, { conversation, architectureResult }) => ({
      ...state,
      conversation,
      currentSessionId: conversation.id,
      sessions: [conversation, ...state.sessions],
      isCreatingNewSession: false,
      loading: false,
      error: null,
    })
  ),
  on(ChatActions.setNewConversationFailure, (state, { error }) => ({
    ...state,
    isCreatingNewSession: false,
    loading: false,
    error,
  })),

  // Send Message
  on(ChatActions.sendMessage, (state) => ({
    ...state,
    loading: true,
    error: null,
  })),
  on(
    ChatActions.sendMessageSuccess,
    (state, { message, architectureResult }) => ({
      ...state,
      conversation: state.conversation
        ? {
            ...state.conversation,
            messages: [...state.conversation.messages, message],
            lastGeneratedConfig: architectureResult,
            updatedAt: message.timestamp,
          }
        : null,
      loading: false,
      error: null,
    })
  ),
  on(ChatActions.sendMessageFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
  })),

  // Load Sessions
  on(ChatActions.loadSessions, (state) => ({
    ...state,
    loading: true,
    error: null,
  })),
  on(ChatActions.loadSessionsSuccess, (state, { sessions }) => ({
    ...state,
    sessions,
    loading: false,
    error: null,
  })),
  on(ChatActions.loadSessionsFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
  })),

  // Clear Conversation
  on(ChatActions.clearConversation, (state) => ({
    ...state,
    loading: true,
    error: null,
  })),
  on(ChatActions.clearConversationSuccess, (state, { sessionId }) => ({
    ...state,
    conversation:
      state.conversation?.id === sessionId
        ? { ...state.conversation, messages: [], lastGeneratedConfig: null }
        : state.conversation,
    loading: false,
    error: null,
  })),
  on(ChatActions.clearConversationFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
  })),

  // Delete Session
  on(ChatActions.deleteSession, (state) => ({
    ...state,
    loading: true,
    error: null,
  })),
  on(ChatActions.deleteSessionSuccess, (state, { sessionId }) => ({
    ...state,
    sessions: state.sessions.filter((s) => s.id !== sessionId),
    conversation:
      state.conversation?.id === sessionId ? null : state.conversation,
    currentSessionId:
      state.currentSessionId === sessionId ? null : state.currentSessionId,
    loading: false,
    error: null,
  })),
  on(ChatActions.deleteSessionFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
  })),

  // Reset State
  on(ChatActions.resetChatState, () => initialChatState)
);

export function chatReducer(state: IChatState | undefined, action: Action) {
  return reducer(state, action);
}


Chat.Selectors

import { createFeatureSelector, createSelector } from '@ngrx/store';
import { CHAT_FEATURE_KEY } from './chat.reducer';
import { IChatState } from './chat.models';

export const selectChatStore = createFeatureSelector<IChatState>(CHAT_FEATURE_KEY);

// Current conversation selectors
export const selectConversation = createSelector(
  selectChatStore,
  (state: IChatState) => state.conversation
);

export const selectCurrentSessionId = createSelector(
  selectChatStore,
  (state: IChatState) => state.currentSessionId
);

export const selectConversationMessages = createSelector(
  selectConversation,
  (conversation) => conversation?.messages || []
);

export const selectLastGeneratedConfig = createSelector(
  selectConversation,
  (conversation) => conversation?.lastGeneratedConfig
);

// Sessions list selectors
export const selectSessions = createSelector(
  selectChatStore,
  (state: IChatState) => state.sessions
);

export const selectSessionsCount = createSelector(
  selectSessions,
  (sessions) => sessions.length
);

// Loading and error selectors
export const selectConversationLoading = createSelector(
  selectChatStore,
  (state: IChatState) => state.loading
);

export const selectConversationError = createSelector(
  selectChatStore,
  (state: IChatState) => state.error
);

export const selectIsCreatingNewSession = createSelector(
  selectChatStore,
  (state: IChatState) => state.isCreatingNewSession
);

export const selectHasError = createSelector(
  selectConversationError,
  (error) => !!error
);

export const selectHasConversation = createSelector(
  selectConversation,
  (conversation) => !!conversation
);


Chat.Actions

import { props, createActionGroup, emptyProps } from '@ngrx/store';
import { IConversationMessage, IConversationSession } from './chat.models';

export const ChatActions = createActionGroup({
  source: 'Chat',
  events: {
    'Set Conversation': props<{ id: string }>(),
    'Set Conversation Success': props<{ conversation: IConversationSession }>(),
    'Set Conversation Failure': props<{ error: string }>(),

    'Set New Conversation': props<{ content: string; userId?: string }>(),
    'Set New Conversation Success': props<{
      conversation: IConversationSession;
      architectureResult: any;
    }>(),
    'Set New Conversation Failure': props<{ error: string }>(),

    'Send Message': props<{ content: string }>(),
    'Send Message Success': props<{
      message: IConversationMessage;
      architectureResult: any;
    }>(),
    'Send Message Failure': props<{ error: string }>(),

    'Load Sessions': props<{ userId: string }>(),
    'Load Sessions Success': props<{ sessions: IConversationSession[] }>(),
    'Load Sessions Failure': props<{ error: string }>(),

    // Clear current conversation
    'Clear Conversation': props<{ sessionId: string }>(),
    'Clear Conversation Success': props<{ sessionId: string }>(),
    'Clear Conversation Failure': props<{ error: string }>(),

    // Delete session
    'Delete Session': props<{ sessionId: string }>(),
    'Delete Session Success': props<{ sessionId: string }>(),
    'Delete Session Failure': props<{ error: string }>(),

    // Reset state
    'Reset Chat State': emptyProps()
  },
});

